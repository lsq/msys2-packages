diff -aurN -x '\.git' a/meson.build b/meson.build
--- a/meson.build
+++ b/meson.build
@@ -57,7 +57,6 @@ zenity_conf.set('DEBUG', get_option('debug'))
 check_headers = [
   'sys/types.h',
   'unistd.h',
-  'langinfo.h',
   'locale.h'
 ]
 
diff -aurN -x '\.git' a/src/arg-nonnull.h b/src/arg-nonnull.h
--- /dev/null
+++ b/src/arg-nonnull.h
@@ -0,0 +1,26 @@
+/* A C macro for declaring that specific arguments must not be NULL.
+   Copyright (C) 2009-2021 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_ARG_NONNULL((n,...,m)) tells the compiler and static analyzer tools
+   that the values passed as arguments n, ..., m must be non-NULL pointers.
+   n = 1 stands for the first argument, n = 2 for the second argument etc.  */
+#ifndef _GL_ARG_NONNULL
+# if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || defined __clang__
+#  define _GL_ARG_NONNULL(params) __attribute__ ((__nonnull__ params))
+# else
+#  define _GL_ARG_NONNULL(params)
+# endif
+#endif
diff -aurN -x '\.git' a/src/langinfo.h b/src/langinfo.h
--- /dev/null
+++ b/src/langinfo.h
@@ -0,0 +1,703 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* Substitute for and wrapper around <langinfo.h>.
+   Copyright (C) 2009-2021 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/*
+ * POSIX <langinfo.h> for platforms that lack it or have an incomplete one.
+ * <https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/langinfo.h.html>
+ */
+
+#ifndef _GL_LANGINFO_H
+
+#if __GNUC__ >= 3
+#pragma GCC system_header
+#endif
+
+
+/* The include_next requires a split double-inclusion guard.  */
+#if 0
+# include_next <langinfo.h>
+#endif
+
+#ifndef _GL_LANGINFO_H
+#define _GL_LANGINFO_H
+
+
+#if !0
+
+/* A platform that lacks <langinfo.h>.  */
+
+/* Assume that it also lacks <nl_types.h> and the nl_item type.  */
+# if !GNULIB_defined_nl_item
+typedef int nl_item;
+#  define GNULIB_defined_nl_item 1
+# endif
+
+/* nl_langinfo items of the LC_CTYPE category */
+# define CODESET     10000
+/* nl_langinfo items of the LC_NUMERIC category */
+# define RADIXCHAR   10001
+# define DECIMAL_POINT RADIXCHAR
+# define THOUSEP     10002
+# define THOUSANDS_SEP THOUSEP
+# define GROUPING    10114
+/* nl_langinfo items of the LC_TIME category */
+# define D_T_FMT     10003
+# define D_FMT       10004
+# define T_FMT       10005
+# define T_FMT_AMPM  10006
+# define AM_STR      10007
+# define PM_STR      10008
+# define DAY_1       10009
+# define DAY_2       (DAY_1 + 1)
+# define DAY_3       (DAY_1 + 2)
+# define DAY_4       (DAY_1 + 3)
+# define DAY_5       (DAY_1 + 4)
+# define DAY_6       (DAY_1 + 5)
+# define DAY_7       (DAY_1 + 6)
+# define ABDAY_1     10016
+# define ABDAY_2     (ABDAY_1 + 1)
+# define ABDAY_3     (ABDAY_1 + 2)
+# define ABDAY_4     (ABDAY_1 + 3)
+# define ABDAY_5     (ABDAY_1 + 4)
+# define ABDAY_6     (ABDAY_1 + 5)
+# define ABDAY_7     (ABDAY_1 + 6)
+# define MON_1       10023
+# define MON_2       (MON_1 + 1)
+# define MON_3       (MON_1 + 2)
+# define MON_4       (MON_1 + 3)
+# define MON_5       (MON_1 + 4)
+# define MON_6       (MON_1 + 5)
+# define MON_7       (MON_1 + 6)
+# define MON_8       (MON_1 + 7)
+# define MON_9       (MON_1 + 8)
+# define MON_10      (MON_1 + 9)
+# define MON_11      (MON_1 + 10)
+# define MON_12      (MON_1 + 11)
+# define ALTMON_1    10200
+# define ALTMON_2    (ALTMON_1 + 1)
+# define ALTMON_3    (ALTMON_1 + 2)
+# define ALTMON_4    (ALTMON_1 + 3)
+# define ALTMON_5    (ALTMON_1 + 4)
+# define ALTMON_6    (ALTMON_1 + 5)
+# define ALTMON_7    (ALTMON_1 + 6)
+# define ALTMON_8    (ALTMON_1 + 7)
+# define ALTMON_9    (ALTMON_1 + 8)
+# define ALTMON_10   (ALTMON_1 + 9)
+# define ALTMON_11   (ALTMON_1 + 10)
+# define ALTMON_12   (ALTMON_1 + 11)
+# define ABMON_1     10035
+# define ABMON_2     (ABMON_1 + 1)
+# define ABMON_3     (ABMON_1 + 2)
+# define ABMON_4     (ABMON_1 + 3)
+# define ABMON_5     (ABMON_1 + 4)
+# define ABMON_6     (ABMON_1 + 5)
+# define ABMON_7     (ABMON_1 + 6)
+# define ABMON_8     (ABMON_1 + 7)
+# define ABMON_9     (ABMON_1 + 8)
+# define ABMON_10    (ABMON_1 + 9)
+# define ABMON_11    (ABMON_1 + 10)
+# define ABMON_12    (ABMON_1 + 11)
+# define ERA         10047
+# define ERA_D_FMT   10048
+# define ERA_D_T_FMT 10049
+# define ERA_T_FMT   10050
+# define ALT_DIGITS  10051
+/* nl_langinfo items of the LC_MONETARY category */
+# define CRNCYSTR    10052
+# define CURRENCY_SYMBOL   CRNCYSTR
+# define INT_CURR_SYMBOL   10100
+# define MON_DECIMAL_POINT 10101
+# define MON_THOUSANDS_SEP 10102
+# define MON_GROUPING      10103
+# define POSITIVE_SIGN     10104
+# define NEGATIVE_SIGN     10105
+# define FRAC_DIGITS       10106
+# define INT_FRAC_DIGITS   10107
+# define P_CS_PRECEDES     10108
+# define N_CS_PRECEDES     10109
+# define P_SEP_BY_SPACE    10110
+# define N_SEP_BY_SPACE    10111
+# define P_SIGN_POSN       10112
+# define N_SIGN_POSN       10113
+/* nl_langinfo items of the LC_MESSAGES category */
+# define YESEXPR     10053
+# define NOEXPR      10054
+
+#else
+
+/* A platform that has <langinfo.h>.  */
+
+# if !0
+#  define CODESET     10000
+#  define GNULIB_defined_CODESET 1
+# endif
+
+# if !0
+#  define T_FMT_AMPM  10006
+#  define GNULIB_defined_T_FMT_AMPM 1
+# endif
+
+# if !0
+#  define ALTMON_1    10200
+#  define ALTMON_2    (ALTMON_1 + 1)
+#  define ALTMON_3    (ALTMON_1 + 2)
+#  define ALTMON_4    (ALTMON_1 + 3)
+#  define ALTMON_5    (ALTMON_1 + 4)
+#  define ALTMON_6    (ALTMON_1 + 5)
+#  define ALTMON_7    (ALTMON_1 + 6)
+#  define ALTMON_8    (ALTMON_1 + 7)
+#  define ALTMON_9    (ALTMON_1 + 8)
+#  define ALTMON_10   (ALTMON_1 + 9)
+#  define ALTMON_11   (ALTMON_1 + 10)
+#  define ALTMON_12   (ALTMON_1 + 11)
+#  define GNULIB_defined_ALTMON 1
+# endif
+
+# if !0
+#  define ERA         10047
+#  define ERA_D_FMT   10048
+#  define ERA_D_T_FMT 10049
+#  define ERA_T_FMT   10050
+#  define ALT_DIGITS  10051
+#  define GNULIB_defined_ERA 1
+# endif
+
+# if !0
+#  define YESEXPR     10053
+#  define NOEXPR      10054
+#  define GNULIB_defined_YESEXPR 1
+# endif
+
+#endif
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2021 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA (func, rettype, parameters);
+   is to be used when func is a Microsoft deprecated alias, on native Windows.
+   It declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to _func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_MDA (open, int, (const char *filename, int flags, ...));
+ */
+#define _GL_CXXALIAS_MDA(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_MDA (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#define _GL_CXXALIAS_MDA_CAST(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_CAST_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2021 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype_gcc, rettype_clang, parameters_and_attributes, "message")
+   is like _GL_WARN_ON_USE (function, "message"), except that in C++ mode the
+   function is declared with the given prototype, consisting of return type,
+   parameters, and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if !defined __cplusplus
+#  define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+     _GL_WARN_ON_USE (function, msg)
+# else
+#  if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes \
+  __attribute__ ((__warning__ (msg)))
+#  elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_clang function parameters_and_attributes \
+  __attribute__ ((__diagnose_if__ (1, msg, "warning")))
+#  elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes
+#  else /* Unsupported.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  endif
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+/* Declare overridden functions.  */
+
+
+/* Return a piece of locale dependent information.
+   Note: The difference between nl_langinfo (CODESET) and locale_charset ()
+   is that the latter normalizes the encoding names to GNU conventions.  */
+
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef nl_langinfo
+#   define nl_langinfo rpl_nl_langinfo
+#  endif
+_GL_FUNCDECL_RPL (nl_langinfo, char *, (nl_item item));
+_GL_CXXALIAS_RPL (nl_langinfo, char *, (nl_item item));
+# else
+#  if !0
+_GL_FUNCDECL_SYS (nl_langinfo, char *, (nl_item item));
+#  endif
+_GL_CXXALIAS_SYS (nl_langinfo, char *, (nl_item item));
+# endif
+_GL_CXXALIASWARN (nl_langinfo);
+#elif defined GNULIB_POSIXCHECK
+# undef nl_langinfo
+# if HAVE_RAW_DECL_NL_LANGINFO
+_GL_WARN_ON_USE (nl_langinfo, "nl_langinfo is not portable - "
+                 "use gnulib module nl_langinfo for portability");
+# endif
+#endif
+
+
+#endif /* _GL_LANGINFO_H */
+#endif /* _GL_LANGINFO_H */
diff -aurN -x '\.git' a/src/meson.build b/src/meson.build
--- a/src/meson.build
+++ b/src/meson.build
@@ -17,6 +17,9 @@ zenity_sources = [
   'tree.c',
   'util.c',
   'zenity-tree-column-view.c',
+  'nl_langinfo.c',
+  'setlocale_null.c',
+  'setlocale-lock.c'
 ]
 
 zenity_cv_enums = gnome.mkenums_simple('zenity-tree-column-view-enums',
diff -aurN -x '\.git' a/src/nl_langinfo.c b/src/nl_langinfo.c
--- /dev/null
+++ b/src/nl_langinfo.c
@@ -0,0 +1,573 @@
+/* nl_langinfo() replacement: query locale dependent information.
+
+   Copyright (C) 2007-2021 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+#include "setlocale_null.h"
+
+/* Specification.  */
+#include <langinfo.h>
+
+#include <locale.h>
+#include <stdlib.h>
+#include <string.h>
+#if defined _WIN32 && ! defined __CYGWIN__
+# define WIN32_LEAN_AND_MEAN  /* avoid including junk */
+# include <windows.h>
+# include <stdio.h>
+#endif
+
+#if REPLACE_NL_LANGINFO && !NL_LANGINFO_MTSAFE
+# if defined _WIN32 && !defined __CYGWIN__
+
+#  define WIN32_LEAN_AND_MEAN  /* avoid including junk */
+#  include <windows.h>
+
+# elif HAVE_PTHREAD_API
+
+#  include <pthread.h>
+#  if HAVE_THREADS_H && HAVE_WEAK_SYMBOLS
+#   include <threads.h>
+#   pragma weak thrd_exit
+#   define c11_threads_in_use() (thrd_exit != NULL)
+#  else
+#   define c11_threads_in_use() 0
+#  endif
+
+# elif HAVE_THREADS_H
+
+#  include <threads.h>
+
+# endif
+#endif
+
+/* nl_langinfo() must be multithread-safe.  To achieve this without using
+   thread-local storage:
+     1. We use a specific static buffer for each possible argument.
+        So that different threads can call nl_langinfo with different arguments,
+        without interfering.
+     2. We use a simple strcpy or memcpy to fill this static buffer.  Filling it
+        through, for example, strcpy + strcat would not be guaranteed to leave
+        the buffer's contents intact if another thread is currently accessing
+        it.  If necessary, the contents is first assembled in a stack-allocated
+        buffer.  */
+
+#if !REPLACE_NL_LANGINFO || GNULIB_defined_CODESET
+/* Return the codeset of the current locale, if this is easily deducible.
+   Otherwise, return "".  */
+static char *
+ctype_codeset (void)
+{
+  static char result[2 + 10 + 1];
+  char buf[2 + 10 + 1];
+  char locale[SETLOCALE_NULL_MAX];
+  char *codeset;
+  size_t codesetlen;
+
+  if (setlocale_null_r (LC_CTYPE, locale, sizeof (locale)))
+    locale[0] = '\0';
+
+  codeset = buf;
+  codeset[0] = '\0';
+
+  if (locale[0])
+    {
+      /* If the locale name contains an encoding after the dot, return it.  */
+      char *dot = strchr (locale, '.');
+
+      if (dot)
+        {
+          /* Look for the possible @... trailer and remove it, if any.  */
+          char *codeset_start = dot + 1;
+          char const *modifier = strchr (codeset_start, '@');
+
+          if (! modifier)
+            codeset = codeset_start;
+          else
+            {
+              codesetlen = modifier - codeset_start;
+              if (codesetlen < sizeof buf)
+                {
+                  codeset = memcpy (buf, codeset_start, codesetlen);
+                  codeset[codesetlen] = '\0';
+                }
+            }
+        }
+    }
+
+# if defined _WIN32 && ! defined __CYGWIN__
+  /* If setlocale is successful, it returns the number of the
+     codepage, as a string.  Otherwise, fall back on Windows API
+     GetACP, which returns the locale's codepage as a number (although
+     this doesn't change according to what the 'setlocale' call specified).
+     Either way, prepend "CP" to make it a valid codeset name.  */
+  codesetlen = strlen (codeset);
+  if (0 < codesetlen && codesetlen < sizeof buf - 2)
+    memmove (buf + 2, codeset, codesetlen + 1);
+  else
+    sprintf (buf + 2, "%u", GetACP ());
+  /* For a locale name such as "French_France.65001", in Windows 10,
+     setlocale now returns "French_France.utf8" instead.  */
+  if (strcmp (buf + 2, "65001") == 0 || strcmp (buf + 2, "utf8") == 0)
+    return (char *) "UTF-8";
+  else
+    {
+      memcpy (buf, "CP", 2);
+      strcpy (result, buf);
+      return result;
+    }
+# else
+  strcpy (result, codeset);
+  return result;
+#endif
+}
+#endif
+
+
+#if REPLACE_NL_LANGINFO
+
+/* Override nl_langinfo with support for added nl_item values.  */
+
+# undef nl_langinfo
+
+/* Without locking, on Solaris 11.3, test-nl_langinfo-mt fails, with message
+   "thread5 disturbed by threadN!", even when threadN invokes only
+      nl_langinfo (CODESET);
+      nl_langinfo (CRNCYSTR);
+   Similarly on Solaris 10.  */
+
+# if !NL_LANGINFO_MTSAFE /* Solaris */
+
+#  define ITEMS (MAXSTRMSG + 1)
+#  define MAX_RESULT_LEN 80
+
+static char *
+nl_langinfo_unlocked (nl_item item)
+{
+  static char result[ITEMS][MAX_RESULT_LEN];
+
+  /* The result of nl_langinfo is in storage that can be overwritten by
+     other calls to nl_langinfo.  */
+  char *tmp = nl_langinfo (item);
+  if (item >= 0 && item < ITEMS && tmp != NULL)
+    {
+      size_t tmp_len = strlen (tmp);
+      if (tmp_len < MAX_RESULT_LEN)
+        strcpy (result[item], tmp);
+      else
+        {
+          /* Produce a truncated result.  Oh well...  */
+          result[item][MAX_RESULT_LEN - 1] = '\0';
+          memcpy (result[item], tmp, MAX_RESULT_LEN - 1);
+        }
+      return result[item];
+    }
+  else
+    return tmp;
+}
+
+/* Use a lock, so that no two threads can invoke nl_langinfo_unlocked
+   at the same time.  */
+
+/* Prohibit renaming this symbol.  */
+#  undef gl_get_nl_langinfo_lock
+
+#  if defined _WIN32 && !defined __CYGWIN__
+
+extern __declspec(dllimport) CRITICAL_SECTION *gl_get_nl_langinfo_lock (void);
+
+static char *
+nl_langinfo_with_lock (nl_item item)
+{
+  CRITICAL_SECTION *lock = gl_get_nl_langinfo_lock ();
+  char *ret;
+
+  EnterCriticalSection (lock);
+  ret = nl_langinfo_unlocked (item);
+  LeaveCriticalSection (lock);
+
+  return ret;
+}
+
+#  elif HAVE_PTHREAD_API
+
+extern
+#   if defined _WIN32 || defined __CYGWIN__
+  __declspec(dllimport)
+#   endif
+  pthread_mutex_t *gl_get_nl_langinfo_lock (void);
+
+#   if HAVE_WEAK_SYMBOLS /* musl libc, FreeBSD, NetBSD, OpenBSD, Haiku */
+
+     /* Avoid the need to link with '-lpthread'.  */
+#    pragma weak pthread_mutex_lock
+#    pragma weak pthread_mutex_unlock
+
+     /* Determine whether libpthread is in use.  */
+#    pragma weak pthread_mutexattr_gettype
+     /* See the comments in lock.h.  */
+#    define pthread_in_use() \
+       (pthread_mutexattr_gettype != NULL || c11_threads_in_use ())
+
+#   else
+#    define pthread_in_use() 1
+#   endif
+
+static char *
+nl_langinfo_with_lock (nl_item item)
+{
+  if (pthread_in_use())
+    {
+      pthread_mutex_t *lock = gl_get_nl_langinfo_lock ();
+      char *ret;
+
+      if (pthread_mutex_lock (lock))
+        abort ();
+      ret = nl_langinfo_unlocked (item);
+      if (pthread_mutex_unlock (lock))
+        abort ();
+
+      return ret;
+    }
+  else
+    return nl_langinfo_unlocked (item);
+}
+
+#  elif HAVE_THREADS_H
+
+extern mtx_t *gl_get_nl_langinfo_lock (void);
+
+static char *
+nl_langinfo_with_lock (nl_item item)
+{
+  mtx_t *lock = gl_get_nl_langinfo_lock ();
+  char *ret;
+
+  if (mtx_lock (lock) != thrd_success)
+    abort ();
+  ret = nl_langinfo_unlocked (item);
+  if (mtx_unlock (lock) != thrd_success)
+    abort ();
+
+  return ret;
+}
+
+#  endif
+
+# else
+
+/* On other platforms, no lock is needed.  */
+#  define nl_langinfo_with_lock nl_langinfo
+
+# endif
+
+char *
+rpl_nl_langinfo (nl_item item)
+{
+  switch (item)
+    {
+# if GNULIB_defined_CODESET
+    case CODESET:
+      return ctype_codeset ();
+# endif
+# if GNULIB_defined_T_FMT_AMPM
+    case T_FMT_AMPM:
+      return (char *) "%I:%M:%S %p";
+# endif
+# if GNULIB_defined_ALTMON
+    case ALTMON_1:
+    case ALTMON_2:
+    case ALTMON_3:
+    case ALTMON_4:
+    case ALTMON_5:
+    case ALTMON_6:
+    case ALTMON_7:
+    case ALTMON_8:
+    case ALTMON_9:
+    case ALTMON_10:
+    case ALTMON_11:
+    case ALTMON_12:
+      /* We don't ship the appropriate localizations with gnulib.  Therefore,
+         treat ALTMON_i like MON_i.  */
+      item = item - ALTMON_1 + MON_1;
+      break;
+# endif
+# if GNULIB_defined_ERA
+    case ERA:
+      /* The format is not standardized.  In glibc it is a sequence of strings
+         of the form "direction:offset:start_date:end_date:era_name:era_format"
+         with an empty string at the end.  */
+      return (char *) "";
+    case ERA_D_FMT:
+      /* The %Ex conversion in strftime behaves like %x if the locale does not
+         have an alternative time format.  */
+      item = D_FMT;
+      break;
+    case ERA_D_T_FMT:
+      /* The %Ec conversion in strftime behaves like %c if the locale does not
+         have an alternative time format.  */
+      item = D_T_FMT;
+      break;
+    case ERA_T_FMT:
+      /* The %EX conversion in strftime behaves like %X if the locale does not
+         have an alternative time format.  */
+      item = T_FMT;
+      break;
+    case ALT_DIGITS:
+      /* The format is not standardized.  In glibc it is a sequence of 10
+         strings, appended in memory.  */
+      return (char *) "\0\0\0\0\0\0\0\0\0\0";
+# endif
+# if GNULIB_defined_YESEXPR || !FUNC_NL_LANGINFO_YESEXPR_WORKS
+    case YESEXPR:
+      return (char *) "^[yY]";
+    case NOEXPR:
+      return (char *) "^[nN]";
+# endif
+    default:
+      break;
+    }
+  return nl_langinfo_with_lock (item);
+}
+
+#else
+
+/* Provide nl_langinfo from scratch, either for native MS-Windows, or
+   for old Unix platforms without locales, such as Linux libc5 or
+   BeOS.  */
+
+# include <time.h>
+
+char *
+nl_langinfo (nl_item item)
+{
+  char buf[100];
+  struct tm tmm = { 0 };
+
+  switch (item)
+    {
+    /* nl_langinfo items of the LC_CTYPE category */
+    case CODESET:
+      {
+        char *codeset = ctype_codeset ();
+        if (*codeset)
+          return codeset;
+      }
+# ifdef __BEOS__
+      return (char *) "UTF-8";
+# else
+      return (char *) "ISO-8859-1";
+# endif
+    /* nl_langinfo items of the LC_NUMERIC category */
+    case RADIXCHAR:
+      return localeconv () ->decimal_point;
+    case THOUSEP:
+      return localeconv () ->thousands_sep;
+# ifdef GROUPING
+    case GROUPING:
+      return localeconv () ->grouping;
+# endif
+    /* nl_langinfo items of the LC_TIME category.
+       TODO: Really use the locale.  */
+    case D_T_FMT:
+    case ERA_D_T_FMT:
+      return (char *) "%a %b %e %H:%M:%S %Y";
+    case D_FMT:
+    case ERA_D_FMT:
+      return (char *) "%m/%d/%y";
+    case T_FMT:
+    case ERA_T_FMT:
+      return (char *) "%H:%M:%S";
+    case T_FMT_AMPM:
+      return (char *) "%I:%M:%S %p";
+    case AM_STR:
+      {
+        static char result[80];
+        if (!strftime (buf, sizeof result, "%p", &tmm))
+          return (char *) "AM";
+        strcpy (result, buf);
+        return result;
+      }
+    case PM_STR:
+      {
+        static char result[80];
+        tmm.tm_hour = 12;
+        if (!strftime (buf, sizeof result, "%p", &tmm))
+          return (char *) "PM";
+        strcpy (result, buf);
+        return result;
+      }
+    case DAY_1:
+    case DAY_2:
+    case DAY_3:
+    case DAY_4:
+    case DAY_5:
+    case DAY_6:
+    case DAY_7:
+      {
+        static char result[7][50];
+        static char const days[][sizeof "Wednesday"] = {
+          "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday",
+          "Friday", "Saturday"
+        };
+        tmm.tm_wday = item - DAY_1;
+        if (!strftime (buf, sizeof result[0], "%A", &tmm))
+          return (char *) days[item - DAY_1];
+        strcpy (result[item - DAY_1], buf);
+        return result[item - DAY_1];
+      }
+    case ABDAY_1:
+    case ABDAY_2:
+    case ABDAY_3:
+    case ABDAY_4:
+    case ABDAY_5:
+    case ABDAY_6:
+    case ABDAY_7:
+      {
+        static char result[7][30];
+        static char const abdays[][sizeof "Sun"] = {
+          "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
+        };
+        tmm.tm_wday = item - ABDAY_1;
+        if (!strftime (buf, sizeof result[0], "%a", &tmm))
+          return (char *) abdays[item - ABDAY_1];
+        strcpy (result[item - ABDAY_1], buf);
+        return result[item - ABDAY_1];
+      }
+    {
+      static char const months[][sizeof "September"] = {
+        "January", "February", "March", "April", "May", "June", "July",
+        "September", "October", "November", "December"
+      };
+      case MON_1:
+      case MON_2:
+      case MON_3:
+      case MON_4:
+      case MON_5:
+      case MON_6:
+      case MON_7:
+      case MON_8:
+      case MON_9:
+      case MON_10:
+      case MON_11:
+      case MON_12:
+        {
+          static char result[12][50];
+          tmm.tm_mon = item - MON_1;
+          if (!strftime (buf, sizeof result[0], "%B", &tmm))
+            return (char *) months[item - MON_1];
+          strcpy (result[item - MON_1], buf);
+          return result[item - MON_1];
+        }
+      case ALTMON_1:
+      case ALTMON_2:
+      case ALTMON_3:
+      case ALTMON_4:
+      case ALTMON_5:
+      case ALTMON_6:
+      case ALTMON_7:
+      case ALTMON_8:
+      case ALTMON_9:
+      case ALTMON_10:
+      case ALTMON_11:
+      case ALTMON_12:
+        {
+          static char result[12][50];
+          tmm.tm_mon = item - ALTMON_1;
+          /* The platforms without nl_langinfo() don't support strftime with
+             %OB.  We don't even need to try.  */
+          #if 0
+          if (!strftime (buf, sizeof result[0], "%OB", &tmm))
+          #endif
+            if (!strftime (buf, sizeof result[0], "%B", &tmm))
+              return (char *) months[item - ALTMON_1];
+          strcpy (result[item - ALTMON_1], buf);
+          return result[item - ALTMON_1];
+        }
+    }
+    case ABMON_1:
+    case ABMON_2:
+    case ABMON_3:
+    case ABMON_4:
+    case ABMON_5:
+    case ABMON_6:
+    case ABMON_7:
+    case ABMON_8:
+    case ABMON_9:
+    case ABMON_10:
+    case ABMON_11:
+    case ABMON_12:
+      {
+        static char result[12][30];
+        static char const abmonths[][sizeof "Jan"] = {
+          "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul",
+          "Sep", "Oct", "Nov", "Dec"
+        };
+        tmm.tm_mon = item - ABMON_1;
+        if (!strftime (buf, sizeof result[0], "%b", &tmm))
+          return (char *) abmonths[item - ABMON_1];
+        strcpy (result[item - ABMON_1], buf);
+        return result[item - ABMON_1];
+      }
+    case ERA:
+      return (char *) "";
+    case ALT_DIGITS:
+      return (char *) "\0\0\0\0\0\0\0\0\0\0";
+    /* nl_langinfo items of the LC_MONETARY category.  */
+    case CRNCYSTR:
+      return localeconv () ->currency_symbol;
+# ifdef INT_CURR_SYMBOL
+    case INT_CURR_SYMBOL:
+      return localeconv () ->int_curr_symbol;
+    case MON_DECIMAL_POINT:
+      return localeconv () ->mon_decimal_point;
+    case MON_THOUSANDS_SEP:
+      return localeconv () ->mon_thousands_sep;
+    case MON_GROUPING:
+      return localeconv () ->mon_grouping;
+    case POSITIVE_SIGN:
+      return localeconv () ->positive_sign;
+    case NEGATIVE_SIGN:
+      return localeconv () ->negative_sign;
+    case FRAC_DIGITS:
+      return & localeconv () ->frac_digits;
+    case INT_FRAC_DIGITS:
+      return & localeconv () ->int_frac_digits;
+    case P_CS_PRECEDES:
+      return & localeconv () ->p_cs_precedes;
+    case N_CS_PRECEDES:
+      return & localeconv () ->n_cs_precedes;
+    case P_SEP_BY_SPACE:
+      return & localeconv () ->p_sep_by_space;
+    case N_SEP_BY_SPACE:
+      return & localeconv () ->n_sep_by_space;
+    case P_SIGN_POSN:
+      return & localeconv () ->p_sign_posn;
+    case N_SIGN_POSN:
+      return & localeconv () ->n_sign_posn;
+# endif
+    /* nl_langinfo items of the LC_MESSAGES category
+       TODO: Really use the locale. */
+    case YESEXPR:
+      return (char *) "^[yY]";
+    case NOEXPR:
+      return (char *) "^[nN]";
+    default:
+      return (char *) "";
+    }
+}
+
+#endif
diff -aurN -x '\.git' a/src/option.c b/src/option.c
--- a/src/option.c
+++ b/src/option.c
@@ -29,7 +29,7 @@
 #include <string.h>
 #include <time.h>
 #include <locale.h>
-#include <langinfo.h>
+#include "langinfo.h"
 
 #include <config.h>
 
diff -aurN -x '\.git' a/src/progress.c b/src/progress.c
--- a/src/progress.c
+++ b/src/progress.c
@@ -48,6 +48,58 @@ static gboolean autokill;
 static gboolean no_cancel;
 static gboolean auto_close;
 
+#if defined _WIN32 && ! defined __CYGWIN__
+# define WIN32_LEAN_AND_MEAN  /* avoid including junk */
+# include <windows.h>
+#include <tlhelp32.h>
+
+typedef __int64 pid_t;
+int kill(pid_t pid, int sig)
+{
+int ret;
+HANDLE h;
+
+h = OpenProcess(PROCESS_TERMINATE, FALSE, pid);
+if (h == NULL) return -1;
+
+ret = TerminateProcess(h, 0) ? 0 : -1;
+CloseHandle(h);
+return ret;
+}
+
+DWORD getppid() {
+  HANDLE hSnapshot = INVALID_HANDLE_VALUE;
+  PROCESSENTRY32 pe32;
+  DWORD ppid = 0, pid = GetCurrentProcessId();
+
+  hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
+  //__try{
+  // try{
+  if (hSnapshot == INVALID_HANDLE_VALUE) //__leave;
+    return -1;
+
+  ZeroMemory(&pe32, sizeof(pe32));
+  pe32.dwSize = sizeof(pe32);
+  if (!Process32First(hSnapshot, &pe32)) //__leave;
+    return -1;
+
+  do {
+    if (pe32.th32ProcessID == pid) {
+      ppid = pe32.th32ParentProcessID;
+      break;
+    }
+  } while (Process32Next(hSnapshot, &pe32));
+
+  //}
+  //__finally{
+  // catch{
+  if (hSnapshot != INVALID_HANDLE_VALUE)
+    CloseHandle(hSnapshot);
+  //}
+  return ppid;
+}
+#endif
+
 static void zenity_progress_dialog_response (GtkWidget *widget, char *rstr, gpointer data);
 
 static gboolean
diff -aurN -x '\.git' a/src/setlocale-lock.c b/src/setlocale-lock.c
--- /dev/null
+++ b/src/setlocale-lock.c
@@ -0,0 +1,150 @@
+/* Return the internal lock used by setlocale_null_r.
+   Copyright (C) 2019-2021 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible <bruno@clisp.org>, 2019.  */
+
+#include <config.h>
+
+/* When it is known that the gl_get_setlocale_null_lock function is defined
+   by a dependency library, it should not be defined here.  */
+#if OMIT_SETLOCALE_LOCK
+
+/* This declaration is solely to ensure that after preprocessing
+   this file is never empty.  */
+typedef int dummy;
+
+#else
+
+/* This file defines the internal lock used by setlocale_null_r.
+   It is a separate compilation unit, so that only one copy of it is
+   present when linking statically.  */
+
+/* Prohibit renaming this symbol.  */
+# undef gl_get_setlocale_null_lock
+
+/* Macro for exporting a symbol (function, not variable) defined in this file,
+   when compiled into a shared library.  */
+# ifndef DLL_EXPORTED
+#  if HAVE_VISIBILITY
+  /* Override the effect of the compiler option '-fvisibility=hidden'.  */
+#   define DLL_EXPORTED __attribute__((__visibility__("default")))
+#  elif defined _WIN32 || defined __CYGWIN__
+#   define DLL_EXPORTED __declspec(dllexport)
+#  else
+#   define DLL_EXPORTED
+#  endif
+# endif
+
+# if defined _WIN32 && !defined __CYGWIN__
+
+#  define WIN32_LEAN_AND_MEAN  /* avoid including junk */
+#  include <windows.h>
+
+#  include "windows-initguard.h"
+
+/* The return type is a 'CRITICAL_SECTION *', not a 'glwthread_mutex_t *',
+   because the latter is not guaranteed to be a stable ABI in the future.  */
+
+/* Make sure the function gets exported from DLLs.  */
+DLL_EXPORTED CRITICAL_SECTION *gl_get_setlocale_null_lock (void);
+
+static glwthread_initguard_t guard = GLWTHREAD_INITGUARD_INIT;
+static CRITICAL_SECTION lock;
+
+/* Returns the internal lock used by setlocale_null_r.  */
+CRITICAL_SECTION *
+gl_get_setlocale_null_lock (void)
+{
+  if (!guard.done)
+    {
+      if (InterlockedIncrement (&guard.started) == 0)
+        {
+          /* This thread is the first one to need the lock.  Initialize it.  */
+          InitializeCriticalSection (&lock);
+          guard.done = 1;
+        }
+      else
+        {
+          /* Don't let guard.started grow and wrap around.  */
+          InterlockedDecrement (&guard.started);
+          /* Yield the CPU while waiting for another thread to finish
+             initializing this mutex.  */
+          while (!guard.done)
+            Sleep (0);
+        }
+    }
+  return &lock;
+}
+
+# elif HAVE_PTHREAD_API
+
+#  include <pthread.h>
+
+static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
+
+/* Make sure the function gets exported from shared libraries.  */
+DLL_EXPORTED pthread_mutex_t *gl_get_setlocale_null_lock (void);
+
+/* Returns the internal lock used by setlocale_null_r.  */
+pthread_mutex_t *
+gl_get_setlocale_null_lock (void)
+{
+  return &mutex;
+}
+
+# elif HAVE_THREADS_H
+
+#  include <threads.h>
+#  include <stdlib.h>
+
+static int volatile init_needed = 1;
+static once_flag init_once = ONCE_FLAG_INIT;
+static mtx_t mutex;
+
+static void
+atomic_init (void)
+{
+  if (mtx_init (&mutex, mtx_plain) != thrd_success)
+    abort ();
+  init_needed = 0;
+}
+
+/* Make sure the function gets exported from shared libraries.  */
+DLL_EXPORTED mtx_t *gl_get_setlocale_null_lock (void);
+
+/* Returns the internal lock used by setlocale_null_r.  */
+mtx_t *
+gl_get_setlocale_null_lock (void)
+{
+  if (init_needed)
+    call_once (&init_once, atomic_init);
+  return &mutex;
+}
+
+# endif
+
+# if (defined _WIN32 || defined __CYGWIN__) && !defined _MSC_VER
+/* Make sure the '__declspec(dllimport)' in setlocale_null.c does not cause
+   a link failure when no DLLs are involved.  */
+#  if defined _WIN64 || defined _LP64
+#   define IMP(x) __imp_##x
+#  else
+#   define IMP(x) _imp__##x
+#  endif
+void * IMP(gl_get_setlocale_null_lock) = &gl_get_setlocale_null_lock;
+# endif
+
+#endif
diff -aurN -x '\.git' a/src/setlocale_null.c b/src/setlocale_null.c
--- /dev/null
+++ b/src/setlocale_null.c
@@ -0,0 +1,411 @@
+/* Query the name of the current global locale.
+   Copyright (C) 2019-2021 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible <bruno@clisp.org>, 2019.  */
+
+#include <config.h>
+
+/* Specification.  */
+#include "setlocale_null.h"
+
+#include <errno.h>
+#include <locale.h>
+#include <stdlib.h>
+#include <string.h>
+#if defined _WIN32 && !defined __CYGWIN__
+# include <wchar.h>
+#endif
+
+#if !(SETLOCALE_NULL_ALL_MTSAFE && SETLOCALE_NULL_ONE_MTSAFE)
+# if defined _WIN32 && !defined __CYGWIN__
+
+#  define WIN32_LEAN_AND_MEAN  /* avoid including junk */
+#  include <windows.h>
+
+# elif HAVE_PTHREAD_API
+
+#  include <pthread.h>
+#  if HAVE_THREADS_H && HAVE_WEAK_SYMBOLS
+#   include <threads.h>
+#   pragma weak thrd_exit
+#   define c11_threads_in_use() (thrd_exit != NULL)
+#  else
+#   define c11_threads_in_use() 0
+#  endif
+
+# elif HAVE_THREADS_H
+
+#  include <threads.h>
+
+# endif
+#endif
+
+/* Use the system's setlocale() function, not the gnulib override, here.  */
+#undef setlocale
+
+static const char *
+setlocale_null_androidfix (int category)
+{
+  const char *result = setlocale (category, NULL);
+
+#ifdef __ANDROID__
+  if (result == NULL)
+    switch (category)
+      {
+      case LC_CTYPE:
+      case LC_NUMERIC:
+      case LC_TIME:
+      case LC_COLLATE:
+      case LC_MONETARY:
+      case LC_MESSAGES:
+      case LC_ALL:
+      case LC_PAPER:
+      case LC_NAME:
+      case LC_ADDRESS:
+      case LC_TELEPHONE:
+      case LC_MEASUREMENT:
+        result = "C";
+        break;
+      default:
+        break;
+      }
+#endif
+
+  return result;
+}
+
+static int
+setlocale_null_unlocked (int category, char *buf, size_t bufsize)
+{
+#if defined _WIN32 && !defined __CYGWIN__ && defined _MSC_VER
+  /* On native Windows, nowadays, the setlocale() implementation is based
+     on _wsetlocale() and uses malloc() for the result.  We are better off
+     using _wsetlocale() directly.  */
+  const wchar_t *result = _wsetlocale (category, NULL);
+
+  if (result == NULL)
+    {
+      /* CATEGORY is invalid.  */
+      if (bufsize > 0)
+        /* Return an empty string in BUF.
+           This is a convenience for callers that don't want to write explicit
+           code for handling EINVAL.  */
+        buf[0] = '\0';
+      return EINVAL;
+    }
+  else
+    {
+      size_t length = wcslen (result);
+      if (length < bufsize)
+        {
+          size_t i;
+
+          /* Convert wchar_t[] -> char[], assuming plain ASCII.  */
+          for (i = 0; i <= length; i++)
+            buf[i] = result[i];
+
+          return 0;
+        }
+      else
+        {
+          if (bufsize > 0)
+            {
+              /* Return a truncated result in BUF.
+                 This is a convenience for callers that don't want to write
+                 explicit code for handling ERANGE.  */
+              size_t i;
+
+              /* Convert wchar_t[] -> char[], assuming plain ASCII.  */
+              for (i = 0; i < bufsize; i++)
+                buf[i] = result[i];
+              buf[bufsize - 1] = '\0';
+            }
+          return ERANGE;
+        }
+    }
+#else
+  const char *result = setlocale_null_androidfix (category);
+
+  if (result == NULL)
+    {
+      /* CATEGORY is invalid.  */
+      if (bufsize > 0)
+        /* Return an empty string in BUF.
+           This is a convenience for callers that don't want to write explicit
+           code for handling EINVAL.  */
+        buf[0] = '\0';
+      return EINVAL;
+    }
+  else
+    {
+      size_t length = strlen (result);
+      if (length < bufsize)
+        {
+          memcpy (buf, result, length + 1);
+          return 0;
+        }
+      else
+        {
+          if (bufsize > 0)
+            {
+              /* Return a truncated result in BUF.
+                 This is a convenience for callers that don't want to write
+                 explicit code for handling ERANGE.  */
+              memcpy (buf, result, bufsize - 1);
+              buf[bufsize - 1] = '\0';
+            }
+          return ERANGE;
+        }
+    }
+#endif
+}
+
+#if !(SETLOCALE_NULL_ALL_MTSAFE && SETLOCALE_NULL_ONE_MTSAFE) /* musl libc, macOS, FreeBSD, NetBSD, OpenBSD, AIX, Haiku, Cygwin */
+
+/* Use a lock, so that no two threads can invoke setlocale_null_unlocked
+   at the same time.  */
+
+/* Prohibit renaming this symbol.  */
+# undef gl_get_setlocale_null_lock
+
+# if defined _WIN32 && !defined __CYGWIN__
+
+extern __declspec(dllimport) CRITICAL_SECTION *gl_get_setlocale_null_lock (void);
+
+static int
+setlocale_null_with_lock (int category, char *buf, size_t bufsize)
+{
+  CRITICAL_SECTION *lock = gl_get_setlocale_null_lock ();
+  int ret;
+
+  EnterCriticalSection (lock);
+  ret = setlocale_null_unlocked (category, buf, bufsize);
+  LeaveCriticalSection (lock);
+
+  return ret;
+}
+
+# elif HAVE_PTHREAD_API /* musl libc, macOS, FreeBSD, NetBSD, OpenBSD, AIX, Haiku, Cygwin */
+
+extern
+#  if defined _WIN32 || defined __CYGWIN__
+  __declspec(dllimport)
+#  endif
+  pthread_mutex_t *gl_get_setlocale_null_lock (void);
+
+#  if HAVE_WEAK_SYMBOLS /* musl libc, FreeBSD, NetBSD, OpenBSD, Haiku */
+
+    /* Avoid the need to link with '-lpthread'.  */
+#   pragma weak pthread_mutex_lock
+#   pragma weak pthread_mutex_unlock
+
+    /* Determine whether libpthread is in use.  */
+#   pragma weak pthread_mutexattr_gettype
+    /* See the comments in lock.h.  */
+#   define pthread_in_use() \
+      (pthread_mutexattr_gettype != NULL || c11_threads_in_use ())
+
+#  else
+#   define pthread_in_use() 1
+#  endif
+
+static int
+setlocale_null_with_lock (int category, char *buf, size_t bufsize)
+{
+  if (pthread_in_use())
+    {
+      pthread_mutex_t *lock = gl_get_setlocale_null_lock ();
+      int ret;
+
+      if (pthread_mutex_lock (lock))
+        abort ();
+      ret = setlocale_null_unlocked (category, buf, bufsize);
+      if (pthread_mutex_unlock (lock))
+        abort ();
+
+      return ret;
+    }
+  else
+    return setlocale_null_unlocked (category, buf, bufsize);
+}
+
+# elif HAVE_THREADS_H
+
+extern mtx_t *gl_get_setlocale_null_lock (void);
+
+static int
+setlocale_null_with_lock (int category, char *buf, size_t bufsize)
+{
+  mtx_t *lock = gl_get_setlocale_null_lock ();
+  int ret;
+
+  if (mtx_lock (lock) != thrd_success)
+    abort ();
+  ret = setlocale_null_unlocked (category, buf, bufsize);
+  if (mtx_unlock (lock) != thrd_success)
+    abort ();
+
+  return ret;
+}
+
+# endif
+
+#endif
+
+int
+setlocale_null_r (int category, char *buf, size_t bufsize)
+{
+#if SETLOCALE_NULL_ALL_MTSAFE
+# if SETLOCALE_NULL_ONE_MTSAFE
+
+  return setlocale_null_unlocked (category, buf, bufsize);
+
+# else
+
+  if (category == LC_ALL)
+    return setlocale_null_unlocked (category, buf, bufsize);
+  else
+    return setlocale_null_with_lock (category, buf, bufsize);
+
+# endif
+#else
+# if SETLOCALE_NULL_ONE_MTSAFE
+
+  if (category == LC_ALL)
+    return setlocale_null_with_lock (category, buf, bufsize);
+  else
+    return setlocale_null_unlocked (category, buf, bufsize);
+
+# else
+
+  return setlocale_null_with_lock (category, buf, bufsize);
+
+# endif
+#endif
+}
+
+const char *
+setlocale_null (int category)
+{
+#if SETLOCALE_NULL_ALL_MTSAFE && SETLOCALE_NULL_ONE_MTSAFE
+  return setlocale_null_androidfix (category);
+#else
+
+  /* This call must be multithread-safe.  To achieve this without using
+     thread-local storage:
+       1. We use a specific static buffer for each possible CATEGORY
+          argument.  So that different threads can call setlocale_mtsafe
+          with different CATEGORY arguments, without interfering.
+       2. We use a simple strcpy or memcpy to fill this static buffer.
+          Filling it through, for example, strcpy + strcat would not be
+          guaranteed to leave the buffer's contents intact if another thread
+          is currently accessing it.  If necessary, the contents is first
+          assembled in a stack-allocated buffer.  */
+  if (category == LC_ALL)
+    {
+# if SETLOCALE_NULL_ALL_MTSAFE
+      return setlocale_null_androidfix (LC_ALL);
+# else
+      char buf[SETLOCALE_NULL_ALL_MAX];
+      static char resultbuf[SETLOCALE_NULL_ALL_MAX];
+
+      if (setlocale_null_r (LC_ALL, buf, sizeof (buf)))
+        return "C";
+      strcpy (resultbuf, buf);
+      return resultbuf;
+# endif
+    }
+  else
+    {
+# if SETLOCALE_NULL_ONE_MTSAFE
+      return setlocale_null_androidfix (category);
+# else
+      enum
+        {
+          LC_CTYPE_INDEX,
+          LC_NUMERIC_INDEX,
+          LC_TIME_INDEX,
+          LC_COLLATE_INDEX,
+          LC_MONETARY_INDEX,
+          LC_MESSAGES_INDEX,
+#  ifdef LC_PAPER
+          LC_PAPER_INDEX,
+#  endif
+#  ifdef LC_NAME
+          LC_NAME_INDEX,
+#  endif
+#  ifdef LC_ADDRESS
+          LC_ADDRESS_INDEX,
+#  endif
+#  ifdef LC_TELEPHONE
+          LC_TELEPHONE_INDEX,
+#  endif
+#  ifdef LC_MEASUREMENT
+          LC_MEASUREMENT_INDEX,
+#  endif
+#  ifdef LC_IDENTIFICATION
+          LC_IDENTIFICATION_INDEX,
+#  endif
+          LC_INDICES_COUNT
+        }
+        i;
+      char buf[SETLOCALE_NULL_MAX];
+      static char resultbuf[LC_INDICES_COUNT][SETLOCALE_NULL_MAX];
+      int err;
+
+      err = setlocale_null_r (category, buf, sizeof (buf));
+      if (err == EINVAL)
+        return NULL;
+      if (err)
+        return "C";
+
+      switch (category)
+        {
+        case LC_CTYPE:          i = LC_CTYPE_INDEX;          break;
+        case LC_NUMERIC:        i = LC_NUMERIC_INDEX;        break;
+        case LC_TIME:           i = LC_TIME_INDEX;           break;
+        case LC_COLLATE:        i = LC_COLLATE_INDEX;        break;
+        case LC_MONETARY:       i = LC_MONETARY_INDEX;       break;
+        case LC_MESSAGES:       i = LC_MESSAGES_INDEX;       break;
+#  ifdef LC_PAPER
+        case LC_PAPER:          i = LC_PAPER_INDEX;          break;
+#  endif
+#  ifdef LC_NAME
+        case LC_NAME:           i = LC_NAME_INDEX;           break;
+#  endif
+#  ifdef LC_ADDRESS
+        case LC_ADDRESS:        i = LC_ADDRESS_INDEX;        break;
+#  endif
+#  ifdef LC_TELEPHONE
+        case LC_TELEPHONE:      i = LC_TELEPHONE_INDEX;      break;
+#  endif
+#  ifdef LC_MEASUREMENT
+        case LC_MEASUREMENT:    i = LC_MEASUREMENT_INDEX;    break;
+#  endif
+#  ifdef LC_IDENTIFICATION
+        case LC_IDENTIFICATION: i = LC_IDENTIFICATION_INDEX; break;
+#  endif
+        default:
+          /* If you get here, a #ifdef LC_xxx is missing.  */
+          abort ();
+        }
+
+      strcpy (resultbuf[i], buf);
+      return resultbuf[i];
+# endif
+    }
+#endif
+}
diff -aurN -x '\.git' a/src/setlocale_null.h b/src/setlocale_null.h
--- /dev/null
+++ b/src/setlocale_null.h
@@ -0,0 +1,83 @@
+/* Query the name of the current global locale.
+   Copyright (C) 2019-2021 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible <bruno@clisp.org>, 2019.  */
+
+#define LC_MESSAGES 6
+#ifndef _SETLOCALE_NULL_H
+#define _SETLOCALE_NULL_H
+
+#include <stddef.h>
+
+#include "arg-nonnull.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Recommended size of a buffer for a locale name for a single category.
+   On glibc systems, you can have locale names that are relative file names;
+   assume a maximum length 256.
+   In native Windows, in 2018 the longest locale name was of length 58
+   ("FYRO Macedonian_Former Yugoslav Republic of Macedonia.1251").  */
+#define SETLOCALE_NULL_MAX (256+1)
+
+/* Recommended size of a buffer for a locale name with all categories.
+   On glibc systems, you can have locale names that are relative file names;
+   assume maximum length 256 for each.  There are 12 categories; so, the
+   maximum total length is 148+12*256.
+   In native Windows, there are 5 categories, and the maximum total length is
+   55+5*58.  */
+#define SETLOCALE_NULL_ALL_MAX (148+12*256+1)
+
+/* setlocale_null_r (CATEGORY, BUF, BUFSIZE) is like setlocale (CATEGORY, NULL),
+   except that
+     - it is guaranteed to be multithread-safe,
+     - it returns the resulting locale category name or locale name in the
+       user-supplied buffer BUF, which must be BUFSIZE bytes long.
+   The recommended minimum buffer size is
+     - SETLOCALE_NULL_MAX for CATEGORY != LC_ALL, and
+     - SETLOCALE_NULL_ALL_MAX for CATEGORY == LC_ALL.
+   The return value is an error code: 0 if the call is successful, EINVAL if
+   CATEGORY is invalid, or ERANGE if BUFSIZE is smaller than the length needed
+   size (including the trailing NUL byte).  In the latter case, a truncated
+   result is returned in BUF, but still NUL-terminated if BUFSIZE > 0.
+   For this call to be multithread-safe, *all* calls to
+   setlocale (CATEGORY, NULL) in all other threads must have been converted
+   to use setlocale_null_r or setlocale_null as well, and the other threads
+   must not make other setlocale invocations (since changing the global locale
+   has side effects on all threads).  */
+extern int setlocale_null_r (int category, char *buf, size_t bufsize)
+  _GL_ARG_NONNULL ((2));
+
+/* setlocale_null (CATEGORY) is like setlocale (CATEGORY, NULL), except that
+   it is guaranteed to be multithread-safe.
+   The return value is NULL if CATEGORY is invalid.
+   For this call to be multithread-safe, *all* calls to
+   setlocale (CATEGORY, NULL) in all other threads must have been converted
+   to use setlocale_null_r or setlocale_null as well, and the other threads
+   must not make other setlocale invocations (since changing the global locale
+   has side effects on all threads).  */
+extern const char *setlocale_null (int category);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _SETLOCALE_NULL_H */
diff -aurN -x '\.git' a/src/windows-initguard.h b/src/windows-initguard.h
--- /dev/null
+++ b/src/windows-initguard.h
@@ -0,0 +1,35 @@
+/* Init guards, somewhat like spinlocks (native Windows implementation).
+   Copyright (C) 2005-2021 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible <bruno@clisp.org>, 2005.
+   Based on GCC's gthr-win32.h.  */
+
+#ifndef _WINDOWS_INITGUARD_H
+#define _WINDOWS_INITGUARD_H
+
+#define WIN32_LEAN_AND_MEAN  /* avoid including junk */
+#include <windows.h>
+
+typedef struct
+        {
+          volatile int done;
+          volatile LONG started;
+        }
+        glwthread_initguard_t;
+
+#define GLWTHREAD_INITGUARD_INIT { 0, -1 }
+
+#endif /* _WINDOWS_INITGUARD_H */
diff -aurN -x '\.git' a/utils/bbe.pl b/utils/bbe.pl
--- /dev/null
+++ b/utils/bbe.pl
@@ -0,0 +1,17 @@
+my $f = shift;
+open(FILE,'<:raw', $f) || die "no open";
+binmode(FILE);
+local $/;
+# while (read(FILE, $buff, 8*2**10)) {
+#     $content .= $buff;
+# }
+my $content = <FILE>;
+close(FILE);
+$content =~ s/perl/C:\/msys64\/usr\/bin\/perl.exe/g;
+# @matches = ($content =~ /(.*)perl(.*)/g);
+# print STDOUT join("C:/msys64/usr/bin/perl.exe", @matches);
+open(FILE,'>:raw', $f) || die "no open";
+binmode(FILE);
+print FILE $content;
+# print FILE join("", @matches);
+close(FILE);
diff -aurN -x '\.git' a/utils/picklee.py b/utils/picklee.py
--- /dev/null
+++ b/utils/picklee.py
@@ -0,0 +1,6 @@
+import pickle
+
+dat = open(r'./build/meson-private/meson_exe_perl.exe_43ea5824cfd7a1fd99110486c1430b0d2b2a758d.dat','rb')
+data = pickle.load(dat)
+print(data)
+print(type(data))
